// Bitmask mapping (least siginificant bits): bits [1, 9] are errors reading a
// sensor, with its sensor_ids value mapping to the bit number. Bit 10 is an
// error when writing a file.
// NOTE(ingar): bitmask will probably be scrapped from libtm and might be moved
// to lib_read_ads_sensors-or_whatever

static uint16_t _error_bitmask;

int libtm_set_error_flag(uint8_t n_bit)
{
    uint16_t mask = 1;
    if (n_bit > N_SENSORS + 1) // +1 for filewrite error
    {
        DEBUG(printf("Invalid sensor id; expected a value between 1 and %d inclusive, was actually %d\n",
                     N_SENSORS + 1, n_bit);)
        return -1;
    }

    _error_bitmask |= 1 << n_bit - 1;
    return 0;
}

uint16_t libtm_get_error_bitmask()
{
    return _error_bitmask;
}

void libtm_reset_error_bitmask()
{
    _error_bitmask = 0;
}

// Should fail when i=11, succeed otherwise
for (uint16_t i = 1; i < 12; ++i)
{
    libtm_set_error_flag(i);
    _error_bitmask = 0;
}

// Should succeed, and _error_bitmask should remain the same every iteration
for (uint16_t i = 0; i < 3; ++i)
{
    libtm_set_error_flag(5);
}


/**
 * @brief Checks if enough time has passed for given sensor_id to write it's data again.
 * @param time_struct_current_time Current time
 * @param sensor_id Sensor ID whose time of last writing should be compared to current time.
 * @return 1 if time passed is larger than sensor's sampling period, 0 elsewise.
 */
int _has_sample_period_passed_since_last_append(int sensor_id)
{

    int current_time_ms = (time_struct_current_time.tv_sec) * 1000 + (time_struct_current_time.tv_usec) / 1000;

    int sensor_last_time_append_ms = last_sample_time_ms[sensor_id - sensor_ID_offset];

    if ((current_time_ms - sensor_last_time_append_ms) >= (int)sensor_list[sensor_id - sensor_ID_offset].sample_period_ms)
    {
        last_sample_time_ms[sensor_id - sensor_ID_offset] = current_time_ms;
        return 1;
    }
    else
    {

        return 0;
    }
}

int libtm_set_sensor_data(float x, float y, float z, uint8_t sensor_id, struct timeval timestamp)
{
    if (sensor_id < 1 || sensor_id >= IMTQ_HOUSEKEEPING)
    {
        DEBUG(printf("Invalid sensor id when setting sensor data; expected a value "
                     "between 1 and %d "
                     "inclusive, was actually %d\n",
                     IMTQ_HOUSEKEEPING - 1, sensor_id);)
        return -1;
    }

    struct vec3 *sensor_data = (struct vec3 *)&_latest_polled_data;
    uint16_t *elapsed_time_since_last_sensor_write =
        (uint16_t *)&_elapsed_time_since_last_sensor_write_ms;

    sensor_data[sensor_id - 1].x = x;
    sensor_data[sensor_id - 1].y = y;
    sensor_data[sensor_id - 1].z = z;
    sensor_data[sensor_id - 1].timestamp_last_write = timestamp;
    elapsed_time_since_last_sensor_write[sensor_id - 1];
